import fs from "fs/promises";
import { resolve, join } from 'path';

interface Theme {
    theme: string;
    swatches: Swatch[];
}

interface Swatch {
    theme: string;
    swatch: string;
    previewColors: string[];
}

(async () => {
    const themesCatalog: Theme[] = [];

    const root = resolve(__dirname, "../");

    const xamlDist = join(root, "dist", "xaml");

    await fs.rm(xamlDist, { recursive: true, force: true });
    await fs.mkdir(xamlDist, { recursive: true });

    const themes = [ "Default", "Bootstrap", "Fluent", "Material" ].map(name => ({
        name,
        path: join(root, "packages", name.toLowerCase())
    }));

    for (const { name, path } of themes) {
        console.log(name.toUpperCase());
        console.log(underline(name, "="));
        console.log();

        await fs.mkdir(join(xamlDist, name, "Swatches"), { recursive: true });

        const themeCatalog: Theme = {
            theme: name,
            swatches: []
        };
        themesCatalog.push(themeCatalog);

        const _swatchesPath = join(path, "scss", "core", "color-system", "_swatch.scss");
        const _palettesPath = join(path, "scss", "core", "color-system", "_palettes.scss");

        const paletteMap = await parseKendoPalettesFile(_palettesPath);

        const resourceDictionary = await parseSwatchesAndCreateResourceDictionary(_swatchesPath, name, "Main", paletteMap);

        await fs.writeFile(join(xamlDist, name, "Swatches", "Main.xaml"), resourceDictionary);
    }

    // await fs.writeFile(
    //     join(xamlDist, "catalog.json"),
    //     JSON.stringify(themesCatalog, null, "  "));

})().catch(console.error);

async function parseKendoPalettesFile(_palettesPath: string): Promise<{ [paletteName: string]: { [colorName: string]: string; }; }> {
    const paletteMap: { [paletteName: string]: { [colorName: string]: string; }; } = {};

    const palettes = await fs.readFile(_palettesPath, "utf-8");
    let lastIndex = 0;

    const paletteStartRegEx = /^\$_default-([a-zA-Z-]*)\s*:\s*\(/gm;

    let paletteStart: RegExpExecArray | null;
    while (paletteStart = paletteStartRegEx.exec(palettes)) {
        const paletteName = "kendo-" + paletteStart[1];

        paletteMap[paletteName] = {};

        console.log(`// Palette ${paletteName}`);
        console.log(`const ${paletteName} = {`);

        lastIndex = paletteStartRegEx.lastIndex;

        // Read colors for the palette....
        const colorVariableRegEx = /\s*([a-zA-Z0-9-]*)\s*:\s*(#[0-9a-fA-F]*)\s*,?/gym;
        const paletteEndRegEx = /\s*\)\s*;/gym;

        while (true) {
            colorVariableRegEx.lastIndex = lastIndex;
            const colorVariable = colorVariableRegEx.exec(palettes);
            if (colorVariable) {
                lastIndex = colorVariableRegEx.lastIndex;
                const colorKey = colorVariable[1];
                const colorValue = colorVariable[2];

                paletteMap[paletteName][colorKey] = colorValue;

                console.log(`  ${colorKey}: ${colorValue},`);
                continue;
            }

            paletteEndRegEx.lastIndex = lastIndex;
            if (paletteEndRegEx.exec(palettes)) {
                console.log(`}\n`);
                break;
            }

            console.log(`Unexpected character at ${lastIndex}`);
            break;
        }
    }
    return paletteMap;
}

async function parseSwatchesAndCreateResourceDictionary(
        _swatchesPath: string,
        themeName: string,
        swatchName: string,
        paletteMap: { [paletteName: string]: { [colorName: string]: string; }; }) {
    const swatches = await fs.readFile(_swatchesPath, "utf-8");

    const defaultColorsStartRegEx = /^\$_default-colors\s*:\s*\(\s*$/mg;

    let rd = "";

    const defaultColorsStart = defaultColorsStartRegEx.exec(swatches);
    if (defaultColorsStart) {
        const line = `<?xml version="1.0" encoding="utf-8" ?>
<?xaml-comp compile="true" ?>
<ResourceDictionary xmlns="http://schemas.microsoft.com/dotnet/2021/maui"
                    xmlns:x="http://schemas.microsoft.com/winfx/2009/xaml"
                    x:Class="Telerik.Theming.${themeName}.Swatches.${swatchName}">

    <!-- This is autogenerated file. Use as reference. Do not modify. -->`;

        console.log(line);
        rd += line + "\n";

        let lastIndex = defaultColorsStartRegEx.lastIndex;

        const commentRegEx = /\s*\/\/\s*(.*)\s*$/gym;
        const kendoPaletteLookupRegEx = /\s*([a-zA-Z-]*)\s*:\s*(k-map-get|map\.get)\s*\(\s*\$([a-zA-Z-]*)\s*,\s*([a-zA-Z\-0-9]*)\s*\)\s*,/gym;
        const filteredPaletteLookupRegEx = /\s*([a-zA-Z-]*)\s*:\s*([a-zA-Z-]*)\s*\(\s*(k-map-get|map\.get)\s*\(\s*\$([a-zA-Z-]*)\s*,\s*([a-zA-Z\-0-9]*)\s*\)\s*(,\s*([.a-zA-Z\-0-9]*))?\)\s*,/gym;

        const endOfMapRegEx = /\s*\)\s*(!default)?\s*;/gym;

        while (true) {
            let result: RegExpExecArray | null;

            commentRegEx.lastIndex = lastIndex;
            result = commentRegEx.exec(swatches);
            if (result) {
                lastIndex = commentRegEx.lastIndex;
                const comment = result[1].trim();

                const line = `\n    <!-- ${comment} -->`;
                console.log(line);
                rd += line + "\n";

                continue;
            }

            kendoPaletteLookupRegEx.lastIndex = lastIndex;
            result = kendoPaletteLookupRegEx.exec(swatches);
            if (result) {
                lastIndex = kendoPaletteLookupRegEx.lastIndex;
                const colorKey = result[1].trim();
                const paletteName = result[3].trim();
                const peletteColorKey = result[4].trim();

                const colorValue = paletteMap[paletteName][peletteColorKey].toUpperCase();

                const line = `    <Color x:Key="${kendoToRadColorNaming(colorKey)}">${colorValue}</Color>`;
                console.log(line);
                rd += line + "\n";

                continue;
            }

            filteredPaletteLookupRegEx.lastIndex = lastIndex;
            result = filteredPaletteLookupRegEx.exec(swatches);
            if (result) {
                lastIndex = filteredPaletteLookupRegEx.lastIndex;

                const colorKey = result[1].trim();

                const paletteName = result[4].trim();
                const peletteColorKey = result[5].trim();

                const filterName = result[2].trim();
                const filterArg = result[7]?.trim();

                let colorValue = paletteMap[paletteName][peletteColorKey].toUpperCase();

                switch (filterName) {
                    case "rgba":
                        if (!filterArg) {
                            console.log("Expected opacity for rgba filter.");
                        }
                        const opacity = Number.parseFloat(filterArg);
                        let alpha = Math.round(opacity * 255).toString(16);
                        if (alpha.length == 1) {
                            alpha = "0" + alpha;
                        }
                        colorValue = (colorValue[0] + alpha + colorValue.substring(1)).toUpperCase();
                        break;
                    default:
                        console.log(`Unknown filter function: ${filterName}!`);
                        continue;
                }

                const line = `    <Color x:Key="${kendoToRadColorNaming(colorKey)}">${colorValue}</Color>`;
                console.log(line);
                rd += line + "\n";

                continue;
            }

            endOfMapRegEx.lastIndex = lastIndex;
            result = endOfMapRegEx.exec(swatches);
            if (result) {
                lastIndex = endOfMapRegEx.lastIndex;

                const line = "\n</ResourceDictionary>";
                console.log(line);
                rd += line + "\n";

                break;
            }

            console.log("Unexpected character at " + lastIndex);
            break;
        }
    }
    return rd;
}

function kendoToRadColorNaming(name: string): string {
    return "Rad" + (name as any).replaceAll(/(^|-)([a-z])/g, (m: any) => m?.[1]?.toUpperCase() ?? m?.[0]?.toUpperCase() ?? "") + "Color";
}

function underline(title: string, char: string = "="): string {
    let underline = "";
    for (let i = 0; i < title.length; i++) {
        underline += char;
    }
    return underline;
}
